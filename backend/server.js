const express = require("express");
const cors = require("cors");
const http = require("http");
const { Server } = require("socket.io");
const { INSTRUCTOR_ID, INSTRUCTOR_ROOM, getStudentRoomId } = require("./config/chatRooms");
require("dotenv").config();

// Import routes
const authRouter = require("./router/authRouter");
const instructorRouter = require("./router/instructorRouter");
const studentRouter = require("./router/studentRouter");
const chatRouter = require("./router/chatRouter");
// New authentication routes
const instructorAuthRouter = require("./router/instructorAuthRouter");
const studentAuthRouter = require("./router/studentAuthRouter");

const app = express();
const server = http.createServer(app);

// Socket.io setup
const io = new Server(server, {
  cors: {
    origin: process.env.FRONTEND_URL || "http://localhost:5173",
    methods: ["GET", "POST"],
  },
});

// Middleware
app.use(cors({
  origin: process.env.FRONTEND_URL || "http://localhost:5173",
  credentials: true
}));

// Middleware ƒë·ªÉ x·ª≠ l√Ω request v·ªõi content-type text/plain v√† application/json
app.use(express.text({ type: 'text/plain' }));
app.use(express.json());

// Middleware ƒë·ªÉ x·ª≠ l√Ω text/plain nh∆∞ JSON
app.use((req, res, next) => {
  // N·∫øu body l√† string v√† content-type l√† text/plain, th·ª≠ parse th√†nh JSON
  if (typeof req.body === 'string' && 
      req.headers['content-type'] && 
      req.headers['content-type'].includes('text/plain')) {
    try {
      req.body = JSON.parse(req.body);
      console.log('Parsed text/plain to JSON:', req.body);
    } catch (e) {
      console.error('Failed to parse text/plain as JSON:', e);
    }
  }
  next();
});

// Routes
app.use("/api", authRouter); // Main auth routes at root level
app.use("/api/instructor", instructorRouter);
app.use("/api/student", studentRouter);
app.use("/api/chat", chatRouter);
// Ph·∫ßn n√†y s·∫Ω ƒë∆∞·ª£c lo·∫°i b·ªè sau khi c·∫≠p nh·∫≠t to√†n b·ªô API
app.use("/api/instructor-auth", instructorAuthRouter);
app.use("/api/student-auth", studentAuthRouter);

// Add plural routes for compatibility with frontend
app.use("/api/instructors", instructorRouter);
app.use("/api/students", studentRouter);

// Test route
app.get("/", (req, res) => {
  res.send("Classroom Management Backend is running üöÄ");
});

// Socket.io for real-time chat and features
const { db } = require("./config/firebaseAdmin");

// Store connected users
const connectedUsers = new Map();

io.on("connection", (socket) => {
  console.log("‚ö° New client connected:", socket.id);

  // Handle user authentication and join their rooms
  socket.on("user-authenticated", async (userData) => {
    try {
      socket.userData = userData;
      const { phone, userType, name } = userData;
      
      // Store user connection
      connectedUsers.set(socket.id, { phone, userType, name });
      
      console.log(`üë§ User authenticated: ${name} (${userType}) - ${phone}`);

      // Join user-specific room
      socket.join(`user_${phone}`);

      // PH∆Ø∆†NG √ÅN ƒê∆†N GI·∫¢N H√ìA:
      // Ch·ªâ c√≥ 1 gi√°o vi√™n v√† c√°c h·ªçc vi√™n c√πng chung ph√≤ng chat
      
      if (userType === 'instructor') {
        // Gi√°o vi√™n tham gia ph√≤ng chat chung
        socket.join(INSTRUCTOR_ROOM);
        console.log(`üè† Instructor joined main room: ${INSTRUCTOR_ROOM}`);
        
        // Gi√°o vi√™n c≈©ng tham gia c√°c ph√≤ng chat c·ªßa t·ª´ng h·ªçc vi√™n
        const studentsSnapshot = await db.collection("students").get();
        console.log(`Found ${studentsSnapshot.size} students for instructor`);
        
        studentsSnapshot.forEach(doc => {
          const studentData = doc.data();
          // ∆Øu ti√™n d√πng email cho h·ªçc vi√™n
          const studentId = studentData.email || studentData.phone;
          
          if (!studentId) {
            console.log(`‚ö†Ô∏è Student ${doc.id} has no ID (email/phone)`);
            return;
          }
          
          // Tham gia ph√≤ng chat ri√™ng c·ªßa h·ªçc vi√™n
          const studentRoom = getStudentRoomId(studentId);
          socket.join(studentRoom);
          console.log(`üè† Instructor joined student room: ${studentRoom}`);
        });
        
        // Cho ph√©p nh·∫≠n tin nh·∫Øn t·ª´ c√°c ƒë·ªãnh d·∫°ng ph√≤ng c≈© (ƒë·ªÉ t∆∞∆°ng th√≠ch)
        socket.join(`chat_${INSTRUCTOR_ID}_*`);
        
      } else if (userType === 'student') {
        // H·ªçc vi√™n tham gia ph√≤ng chat chung v·ªõi gi√°o vi√™n
        socket.join(INSTRUCTOR_ROOM);
        console.log(`üè† Student joined main room: ${INSTRUCTOR_ROOM}`);
        
        // H·ªçc vi√™n c≈©ng tham gia ph√≤ng chat ri√™ng c·ªßa m√¨nh
        const studentId = phone; // phone ch√≠nh l√† ID h·ªçc vi√™n (c√≥ th·ªÉ l√† email)
        const studentRoom = getStudentRoomId(studentId);
        socket.join(studentRoom);
        console.log(`üè† Student joined personal room: ${studentRoom}`);
        
        // Cho ph√©p nh·∫≠n tin nh·∫Øn t·ª´ c√°c ƒë·ªãnh d·∫°ng ph√≤ng c≈© (ƒë·ªÉ t∆∞∆°ng th√≠ch)
        const compatRoomId = `chat_instructor1_${studentId}`;
        socket.join(compatRoomId);
        console.log(`üè† Student also joined compatibility room: ${compatRoomId}`);
      }

      // Notify user is online
      socket.broadcast.emit('user-online', {
        phone,
        userType,
        name
      });

    } catch (error) {
      console.error("‚ùå Error in user authentication:", error);
    }
  });

  // Handle joining specific chat room
  socket.on("join-chat-room", async (roomId) => {
    // PH∆Ø∆†NG √ÅN ƒê∆†N GI·∫¢N H√ìA:
    // ƒê∆°n gi·∫£n h√≥a vi·ªác tham gia ph√≤ng chat
    
    // X√°c ƒë·ªãnh lo·∫°i ng∆∞·ªùi d√πng v√† ID
    const userType = socket.userData?.userType;
    const userId = socket.userData?.phone || socket.userData?.email;
    
    let standardRoomId;
    
    if (userType === 'instructor') {
      // Gi√°o vi√™n lu√¥n tham gia ph√≤ng ch√≠nh
      standardRoomId = INSTRUCTOR_ROOM;
      
      // Ki·ªÉm tra xem gi√°o vi√™n c√≥ ƒëang c·ªë g·∫Øng tham gia ph√≤ng ri√™ng c·ªßa h·ªçc vi√™n n√†o kh√¥ng
      if (roomId.includes('_student_') || roomId.includes('instructor1_')) {
        // Tr√≠ch xu·∫•t ID h·ªçc vi√™n t·ª´ roomId
        let studentId;
        if (roomId.includes('_student_')) {
          studentId = roomId.split('_student_')[1];
        } else if (roomId.includes('instructor1_')) {
          studentId = roomId.split('instructor1_')[1];
        }
        
        if (studentId) {
          // Tham gia ph√≤ng ri√™ng c·ªßa h·ªçc vi√™n
          const studentRoom = getStudentRoomId(studentId);
          socket.join(studentRoom);
          console.log(`üí¨ Instructor joining student room: ${studentRoom}`);
        }
      }
    } else if (userType === 'student') {
      // H·ªçc vi√™n lu√¥n tham gia ph√≤ng ch√≠nh
      standardRoomId = INSTRUCTOR_ROOM;
      
      // H·ªçc vi√™n c≈©ng tham gia ph√≤ng ri√™ng c·ªßa m√¨nh
      const studentRoom = getStudentRoomId(userId);
      socket.join(studentRoom);
      console.log(`ÔøΩ Student joining personal room: ${studentRoom}`);
    }
    
    // Tham gia ph√≤ng ch√≠nh
    socket.join(standardRoomId);
    console.log(`üí¨ User ${socket.id} joined chat room: ${standardRoomId}`);
    
    // Log all rooms this socket is in for debugging
    const rooms = Array.from(socket.rooms);
    console.log(`üîç Socket ${socket.id} is now in rooms:`, rooms);
    
    // Notify others in the room
    socket.to(standardRoomId).emit('user-joined-chat', {
      userId: userId,
      userName: socket.userData?.name,
      userType: userType
    });
    
    // Tham gia c·∫£ ph√≤ng g·ªëc ƒë·ªÉ ƒë·∫£m b·∫£o t∆∞∆°ng th√≠ch
    socket.join(roomId);
  });

  // Handle sending messages
  socket.on("send-message", async (messageData) => {
    try {
      const { roomId, from, fromName, fromType, message, messageType = 'text', to = null } = messageData;
      
      console.log(`üí¨ Message received: ${fromName} -> Room ${roomId} -> To: ${to || 'all'}`);

      // Validate message data
      if (!from || !fromName || !fromType || !message) {
        socket.emit('message-error', { 
          error: 'Missing required message data',
          tempId: messageData.tempId // Return the tempId for frontend error handling
        });
        return;
      }

      // PH∆Ø∆†NG √ÅN C·∫¢I TI·∫æN:
      // X√°c ƒë·ªãnh ph√≤ng chat c·∫ßn g·ª≠i tin nh·∫Øn v√† ng∆∞·ªùi nh·∫≠n c·ª• th·ªÉ
      let targetRoomId;
      let recipientId = to;
      
      if (fromType === 'instructor') {
        // N·∫øu l√† gi√°o vi√™n g·ª≠i, x√°c ƒë·ªãnh ng∆∞·ªùi nh·∫≠n t·ª´ tham s·ªë ho·∫∑c roomId
        if (roomId.includes('_student_')) {
          // Ph√≤ng c√° nh√¢n c·ªßa h·ªçc vi√™n
          recipientId = to || roomId.split('_student_')[1];
          targetRoomId = getStudentRoomId(recipientId);
        } else if (to) {
          // C√≥ ch·ªâ ƒë·ªãnh ng∆∞·ªùi nh·∫≠n c·ª• th·ªÉ
          targetRoomId = getStudentRoomId(to);
        } else {
          // Kh√¥ng x√°c ƒë·ªãnh ƒë∆∞·ª£c ng∆∞·ªùi nh·∫≠n, s·ª≠ d·ª•ng roomId g·ªëc
          targetRoomId = roomId;
        }
      } else {
        // H·ªçc vi√™n g·ª≠i tin nh·∫Øn ƒë·∫øn ph√≤ng ri√™ng c·ªßa m√¨nh v√† ng∆∞·ªùi nh·∫≠n l√† instructor
        targetRoomId = getStudentRoomId(from);
        recipientId = INSTRUCTOR_ID; // G·ª≠i cho gi√°o vi√™n
      }

      // Create message document
      const messageDoc = {
        from,
        fromName,
        fromType,
        message: message.trim(),
        messageType,
        timestamp: new Date(),
        read: false,
        targetRoomId, // L∆∞u ph√≤ng ƒë√≠ch ƒë·ªÉ d·ªÖ truy v·∫•n sau n√†y
        to: recipientId, // L∆∞u th√¥ng tin ng∆∞·ªùi nh·∫≠n c·ª• th·ªÉ
        originalRoomId: roomId // L∆∞u roomId g·ªëc t·ª´ client
      };

      // Save to Firebase
      // L∆∞u v√†o collection chung cho d·ªÖ qu·∫£n l√Ω
      const messageRef = await db.collection("chatMessages").add(messageDoc);

      // C·∫≠p nh·∫≠t metadata cho ph√≤ng chat
      await db.collection("chatRooms").doc(targetRoomId).set({
        lastMessage: message.trim(),
        lastMessageFrom: fromName,
        lastMessageAt: new Date(),
        participants: [from, recipientId].filter(Boolean), // L∆∞u c·∫£ ng∆∞·ªùi g·ª≠i v√† ng∆∞·ªùi nh·∫≠n
        updatedAt: new Date()
      }, { merge: true });

      const savedMessage = {
        id: messageRef.id,
        ...messageDoc
      };

      // ƒê·∫£m b·∫£o timestamp ƒë∆∞·ª£c chuy·ªÉn ƒë·ªïi ƒë√∫ng c√°ch
      const serializedMessage = {
        ...savedMessage,
        timestamp: savedMessage.timestamp.toISOString(),
        roomId: targetRoomId // ƒê·∫£m b·∫£o client nh·∫≠n ƒë∆∞·ª£c roomId ƒë√∫ng
      };
      
      // Debug log: ki·ªÉm tra s·ªë client trong ph√≤ng chat
      const roomSockets = await io.in(targetRoomId).fetchSockets();
      console.log(`üì¢ Broadcasting to ${roomSockets.length} clients in room ${targetRoomId}`);
      roomSockets.forEach(s => console.log(` - Socket ${s.id} in room`));
      
      // Tr∆∞·ªùng h·ª£p 1: G·ª≠i tin nh·∫Øn tr·ª±c ti·∫øp ƒë·∫øn socket c·ªßa ng∆∞·ªùi g·ª≠i v√† ng∆∞·ªùi nh·∫≠n
      if (recipientId) {
        // G·ª≠i cho ng∆∞·ªùi nh·∫≠n c·ª• th·ªÉ (n·∫øu c√≥)
        if (fromType === 'instructor') {
          // G·ª≠i tin nh·∫Øn ƒë·∫øn ph√≤ng c·ªßa h·ªçc vi√™n
          const studentRoom = getStudentRoomId(recipientId);
          io.to(studentRoom).emit('receive-message', {
            ...serializedMessage,
            specificRecipient: recipientId
          });
          console.log(`üì¢ Sending to specific student room: ${studentRoom}`);
        } else {
          // N·∫øu ng∆∞·ªùi g·ª≠i l√† h·ªçc vi√™n, g·ª≠i ƒë·∫øn ph√≤ng c·ªßa gi√°o vi√™n
          io.to(`user_${INSTRUCTOR_ID}`).emit('receive-message', {
            ...serializedMessage,
            specificRecipient: INSTRUCTOR_ID
          });
          console.log(`üì¢ Sending to instructor's personal room: user_${INSTRUCTOR_ID}`);
        }
      }
      
      // Tr∆∞·ªùng h·ª£p 2: G·ª≠i tin nh·∫Øn ƒë·∫øn ph√≤ng g·ªëc ƒë·ªÉ ƒë·∫£m b·∫£o ng∆∞·ªùi g·ª≠i lu√¥n nh·∫≠n ƒë∆∞·ª£c
      io.to(roomId).emit('receive-message', serializedMessage);
      
      // Tr∆∞·ªùng h·ª£p 3: G·ª≠i tin nh·∫Øn ƒë·∫øn ph√≤ng ƒë√≠ch (n·∫øu kh√°c v·ªõi ph√≤ng g·ªëc)
      if (roomId !== targetRoomId) {
        io.to(targetRoomId).emit('receive-message', serializedMessage);
        console.log(`üì¢ Also broadcasting to target room: ${targetRoomId}`);
      }
      
      // T∆∞∆°ng th√≠ch ng∆∞·ª£c - g·ª≠i ƒë·∫øn ph√≤ng ƒë·ªãnh d·∫°ng c≈©
      if (fromType === 'instructor' && recipientId) {
        const legacyRoomId = `chat_instructor1_${recipientId}`;
        io.to(legacyRoomId).emit('receive-message', serializedMessage);
        console.log(`üì¢ Also broadcasting to legacy room: ${legacyRoomId}`);
      }
      
      // Send delivery confirmation to sender
      socket.emit('message-sent', {
        tempId: messageData.tempId, // For frontend message tracking
        messageId: messageRef.id,
        roomId: targetRoomId, // Add roomId for consistent tracking
        timestamp: messageDoc.timestamp.toISOString()
      });

      console.log(`‚úÖ Message saved and broadcasted: ${messageRef.id} in room ${targetRoomId}`);

    } catch (error) {
      console.error("‚ùå Error handling message:", error);
      socket.emit('message-error', { 
        error: 'Failed to send message',
        tempId: messageData.tempId, // Return the tempId for frontend error handling
        details: process.env.NODE_ENV !== 'production' ? error.message : undefined
      });
    }
  });

  // Handle typing indicators
  socket.on("typing-start", (data) => {
    const { roomId, userName, userType } = data;
    socket.to(roomId).emit('user-typing', {
      userName,
      userType,
      isTyping: true
    });
  });

  socket.on("typing-stop", (data) => {
    const { roomId, userName, userType } = data;
    socket.to(roomId).emit('user-typing', {
      userName,
      userType,
      isTyping: false
    });
  });

  // Handle message read status
  socket.on("mark-messages-read", async (data) => {
    try {
      const { roomId, userId } = data;
      
      // Update read status in database
      const unreadSnapshot = await db.collection("chatRooms")
        .doc(roomId)
        .collection("messages")
        .where("read", "==", false)
        .where("from", "!=", userId)
        .get();

      if (!unreadSnapshot.empty) {
        const batch = db.batch();
        unreadSnapshot.forEach(doc => {
          batch.update(doc.ref, { read: true });
        });
        await batch.commit();

        // Notify room about read status
        socket.to(roomId).emit('messages-read', {
          readBy: userId,
          count: unreadSnapshot.size
        });

        console.log(`üëÅÔ∏è Marked ${unreadSnapshot.size} messages as read in ${roomId}`);
      }

    } catch (error) {
      console.error("‚ùå Error marking messages as read:", error);
    }
  });

  // Handle instructor events
  socket.on("student-added", (studentData) => {
    io.emit("student-list-updated", studentData);
    console.log(`üìö Student added broadcast: ${studentData.name}`);
  });

  socket.on("lesson-assigned", (lessonData) => {
    const { studentPhone } = lessonData;
    io.to(`user_${studentPhone}`).emit("new-lesson", lessonData);
    console.log(`üìñ Lesson assigned to: ${studentPhone}`);
  });

  // Handle student events
  socket.on("lesson-completed", (lessonData) => {
    io.emit("lesson-completed", lessonData);
    console.log(`‚úÖ Lesson completed: ${lessonData.title}`);
  });

  // Handle disconnect
  socket.on("disconnect", () => {
    const userData = connectedUsers.get(socket.id);
    if (userData) {
      // Notify others user is offline
      socket.broadcast.emit('user-offline', {
        phone: userData.phone,
        userType: userData.userType,
        name: userData.name
      });
      
      connectedUsers.delete(socket.id);
      console.log(`üëã User disconnected: ${userData.name} (${userData.userType})`);
    } else {
      console.log("üëã Client disconnected:", socket.id);
    }
  });

  // Handle errors
  socket.on("error", (error) => {
    console.error("‚ùå Socket error:", error);
  });
});

// Make io accessible to routes
app.set("io", io);

// Error handling middleware
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).json({ error: "Something went wrong!" });
});

// Start server
const PORT = process.env.PORT || 5000;
server.listen(PORT, () => {
  console.log(`üöÄ Server running on port ${PORT}`);
  console.log(`üì± Frontend URL: ${process.env.FRONTEND_URL}`);
  console.log(`üí¨ Real-time chat enabled`);
});